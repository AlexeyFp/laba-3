'''
С клавиатуры вводится два числа K и N.
Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E заполняется случайным образом целыми числами в интервале [-10,10].
Для тестирования использовать не случайное заполнение, а целенаправленное.
Формируется матрица F следующим образом: если в С количество положительных элементов в четных столбцах в области 2 больше, чем количество отрицательных  элементов в нечетных столбцах в области 4, то поменять в С симметрично области 1 и 3 местами, иначе С и Е поменять местами несимметрично.
При этом матрица А не меняется. После чего вычисляется выражение: (F+A)*AT – K * F.
Выводятся по мере формирования А, F и все матричные операции последовательно.
Вид матрицы A:
E B
D C

Каждая из матриц B,C,D,E имеет вид:    1
                                     4   2
                                       3
'''


def print_matrix(mat, title):
    print(f"\n{title}:")
    for row in mat:
        print(' '.join(f"{x:4}" for x in row))

def create_matrix(N):
    mat = [[0]*N for _ in range(N)]
    if N == 4:
        return [[0,2,1,1],[3,0,1,1],[1,1,1,1],[1,1,1,1]]
    if N == 6:
        return [[0,1,0,2,3,4],[5,0,6,7,8,9],[1,2,3,4,5,6],
                [7,8,9,0,1,2],[3,4,5,6,7,8],[9,0,1,2,3,4]]
    val = -10
    for i in range(N):
        for j in range(N):
            mat[i][j] = val
            val = val + 1 if val < 10 else -10
    return mat

def transpose(mat):
    N = len(mat)
    return [[mat[i][j] for i in range(N)] for j in range(N)]

def add(A, B):
    N = len(A)
    return [[A[i][j] + B[i][j] for j in range(N)] for i in range(N)]

def mul_scalar(mat, k):
    N = len(mat)
    return [[k * mat[i][j] for j in range(N)] for i in range(N)]

def mul(A, B):
    N = len(A)
    C = [[0]*N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            C[i][j] = sum(A[i][t] * B[t][j] for t in range(N))
    return C

def sub(A, B):
    N = len(A)
    return [[A[i][j] - B[i][j] for j in range(N)] for i in range(N)]

def main():
    K = int(input("Введите K: "))
    N = int(input("Введите N (чётное, >= 2): "))
    if N % 2 != 0 or N < 2:
        print("Ошибка: N должно быть чётным и не меньше 2.")
        return

    A = create_matrix(N)
    print_matrix(A, "Матрица A")
    n = N // 2

    E = [row[:n] for row in A[:n]]
    B = [row[n:] for row in A[:n]]
    C = [row[n:] for row in A[n:]]
    print_matrix(E, "Подматрица E")

    count_zeros = 0
    for i in range(n):
        for j in range(n):
            if i < j and i + j < n - 1 and j % 2 == 0 and E[i][j] == 0:
                count_zeros += 1

    prod_area2, has_elem = 1, False
    for i in range(n):
        for j in range(n):
            if i < j and i + j > n - 1:
                prod_area2 *= E[i][j]
                has_elem = True
    if not has_elem:
        prod_area2 = 0

    print(f"\nКоличество нулей в нечётных столбцах области 1 в E: {count_zeros}")
    print(f"Произведение элементов области 2 в E: {prod_area2}")

    F = [row[:] for row in A]
    if count_zeros > prod_area2:
        print("\nУсловие выполнено: меняем в B симметрично области 1 и 3 местами")
        B_new = [row[:] for row in B]
        for i in range(n):
            for j in range(n):
                if i < j and i + j < n - 1:
                    i3, j3 = n - 1 - j, n - 1 - i
                    if i3 > j3 and i3 + j3 > n - 1:
                        B_new[i][j], B_new[i3][j3] = B[i3][j3], B[i][j]
        for i in range(n):
            for j in range(n):
                F[i][j + n] = B_new[i][j]
    else:
        print("\nУсловие не выполнено: меняем C и E местами несимметрично")
        for i in range(n):
            for j in range(n):
                F[i][j] = C[i][j]
                F[i + n][j + n] = E[i][j]

    print_matrix(F, "Матрица F")

    AT, FT = transpose(A), transpose(F)
    FA = add(F, A)
    print_matrix(FA, "F + A")

    K_AT = mul_scalar(AT, K)
    print_matrix(K_AT, f"K * A^T")

    part1 = mul(K_AT, FA)
    print_matrix(part1, "(K * A^T) * (F + A)")

    K_FT = mul_scalar(FT, K)
    print_matrix(K_FT, "K * F^T")

    result = sub(part1, K_FT)
    print_matrix(result, "Результат: ((K * A^T) * (F + A)) - K * F^T")

if __name__ == "__main__":
    main()
